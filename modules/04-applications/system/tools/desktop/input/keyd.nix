{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.maxos.tools.keyd;
  
in {
  options.maxos.tools.keyd = {
    enable = mkEnableOption "Enable keyd for key remapping";

    deviceIds = mkOption {
      type = types.str;
      default = "046d:*"; # Default to all Logitech devices
      description = "Device IDs to apply keyd configuration to (vendor:product format). Example: \"046d:c09d\" or \"*\" for all.";
    };

    audioDevice = mkOption {
      type = types.str;
      default = "@DEFAULT_AUDIO_SOURCE@";
      description = "The audio device name or ID for wpctl to control (e.g., '@DEFAULT_AUDIO_SOURCE@' or a specific ID like 'alsa_input.usb-GN_Netcom_A_S_Jabra_EVOLVE_20_MS_A00593147A220A-00.mono-fallback').";
    };

    keyMappings = mkOption {
      type = types.nullOr types.str; # Allow null or a multi-line string
      default = null;
      description = "Custom key mappings for keyd as a multi-line string. If null, a default mapping for BTN_SIDE to control the specified audioDevice will be generated.";
      example = ''
        BTN_SIDE = macro(exec('...') P release exec('...'))
        # another_key = some_other_action
      '';
    };

  };

  config = mkIf cfg.enable (
    let
      # Get the primary username and UID.
      userName = config.users.users.user.name;
      userUid = toString config.users.users.user.uid;

      # Define the actual commands
      fullUnmuteCmd = "sudo -u ${userName} XDG_RUNTIME_DIR=/run/user/${userUid} DISPLAY=:0 DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/${userUid}/bus wpctl set-mute ${cfg.audioDevice} 0";
      fullMuteCmd = "sudo -u ${userName} XDG_RUNTIME_DIR=/run/user/${userUid} DISPLAY=:0 DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/${userUid}/bus wpctl set-mute ${cfg.audioDevice} 1";

      # Definitions for PTT helper scripts (keydPttUnmuteScript, keydPttMuteScript,
      # keydUnmuteExec, keydMuteExec) are removed as this module will no longer
      # provide a default PTT configuration.

      # actualKeyMappings will now only use user-provided mappings.
      # If cfg.keyMappings is null (default), no specific PTT mapping will be generated by this module.
      actualKeyMappings = if cfg.keyMappings == null then "" else cfg.keyMappings;
    in {
      # Create the 'keyd' user and group
      users.groups.keyd = {};
      users.users.keyd = {
        isSystemUser = true;
        group = "keyd"; # Primary group
        extraGroups = [ "input" "uinput" ]; # Add to input and uinput groups for device access
        description = "System user for keyd daemon";
      };

      # Install keyd package, helper scripts, and necessary tools
      environment.systemPackages = with pkgs; [
        keyd # Keep keyd itself if user wants it for other things
        # keydPttUnmuteScript and keydPttMuteScript removed from packages
        evtest              # For debugging input devices
        pipewire            # Provides wpctl
      ];

      # Try to enable keyd service if it exists in NixOS
      services.keyd = {
        enable = true;
        # 'user' and 'group' options do not exist for services.keyd
        # The service starts as root, and keyd drops privileges itself.
      };

      # Allow keyd (when started as root by its service) to change UID/GID.
      # The keyd daemon attempts to setgid/setuid to 'keyd':'keyd'.
      # The default systemd unit for keyd in Nixpkgs has RestrictSUIDSGID=true,
      # which prevents this. We need to override it.
      systemd.services.keyd.serviceConfig = {
        RestrictSUIDSGID = mkForce false; # Allow keyd to call setuid/setgid
        # Ensure keyd has the capabilities to change UID/GID and other needed operations.
        CapabilityBoundingSet = mkForce [
          "CAP_SETUID"        # Needed for setuid
          "CAP_SETGID"        # Needed for setgid
          "CAP_SYS_NICE"      # From default NixOS keyd unit
        ];
        AmbientCapabilities = mkForce [
          "CAP_SETUID"
          "CAP_SETGID"
          "CAP_SYS_NICE"
        ];
        # ExecStart is no longer overridden here;
        # we revert to the default ExecStart provided by services.keyd.enable = true;
        # This removes the -m (monitor/verbose) flag.
      };

      # Configure keyd via environment.etc
      environment.etc."keyd/default.conf" = {
        text = ''
          [ids]
          ${cfg.deviceIds}

          [main]
          ${actualKeyMappings}
        '';
        mode = "0644";
      };
    
    # The custom systemd service definition below is removed,
    # as we are now relying on the standard NixOS `services.keyd.enable = true;`
    # which correctly sets up the user and group for the keyd daemon.
    
    # Add documentation
    environment.etc."keyd-readme".text = ''
      # keyd Configuration
      
      keyd has been installed on this system for key remapping.
      
      ## Current Configuration
      
      The current configuration applies to devices matching: ${cfg.deviceIds}
      
      Key mappings:
      ${if cfg.keyMappings != null then cfg.keyMappings else "# Default BTN_SIDE mapping will be used (not shown here as it's generated dynamically)"}
      
      ## Setup
      
      If keyd is not running automatically, you can set it up manually:
      
      ```
      setup-keyd
      ```
      
      ## Troubleshooting
      
      To monitor keyd events, run:
      
      ```
      sudo keyd-monitor
      ```
      
      To identify your input devices, run:
      
      ```
      sudo evtest
      ```
      
      To check if keyd is running:
      
      ```
      systemctl status keyd
      ```
      
      For more information, see the keyd documentation:
      https://github.com/rvaiya/keyd
    '';
    
    # Add a message to inform the user about the keyd setup
    system.activationScripts.keydSetupMessage = ''
      echo ""
      echo "=== keyd Configuration ==="
      echo "keyd has been configured to map your mouse button to microphone control."
      echo "If it's not working automatically, run: setup-keyd"
      echo "=========================="
      echo ""
    '';
  });
}